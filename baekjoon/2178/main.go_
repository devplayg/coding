package main

import (
	"container/list"
	"fmt"
)

type Queue struct {
	qy *list.List
	qx *list.List
	qc *list.List
}

func newQueue(y, x, c int) *Queue {
	q := Queue{
		qy: list.New(),
		qx: list.New(),
		qc: list.New(),
	}
	q.qy.PushBack(y)
	q.qx.PushBack(x)
	q.qc.PushBack(c)
	return &q
}

func (q *Queue) Enqueue(y, x, c int) {
	q.qy.PushBack(y)
	q.qx.PushBack(x)
	q.qc.PushBack(c)
	visited[y][x] = true
	//q.Print("enqueue", y, x, c)
}

func (q *Queue) Print(prefix string, y, x, c int) {
	fmt.Printf("[%s] %d-%d-%d\n", prefix, y, x, c)
}

func (q *Queue) DeQueue() (y, x, c int) {
	if front := q.qy.Front(); front != nil {
		y = front.Value.(int)
		q.qy.Remove(front)
	}
	if front := q.qx.Front(); front != nil {
		x = front.Value.(int)
		q.qx.Remove(front)
	}
	if front := q.qc.Front(); front != nil {
		c = front.Value.(int)
		q.qc.Remove(front)
	}

	return y, x, c
}

func (q *Queue) Status() {
	for e := q.qy.Front(); e != nil ; e = e.Next() {
		fmt.Printf("(%d, ?)", e.Value.(int))
	}
	println("")
}

var N int
var M int

const MaxSize = 100

var arr = [MaxSize+1][MaxSize+1]int{}
var visited = [MaxSize+1][MaxSize+1]bool{}

func valid(y, x int) bool {
	if !isInBound(y, x) {
		//fmt.Printf("[notblock] y=%d, x=%d\n", y,x)
		return false
	}
	if arr[y][x] == 0 {
		//fmt.Printf("[wall] y=%d, x=%d\n", y,x)
		return false
	}

	if visited[y][x] {
		//fmt.Printf("[already] y=%d, x=%d\n", y,x)
		return false
	}
	return true
}

func isInBound(y, x int) bool {
	if y > 0 && y <= N && x > 0 && x <= M {
		return true
	}
	return false
}

func main() {
	fmt.Scanf("%d %d", &N, &M)
	for y := 1; y <= N; y++ {
		for x := 1; x <= M; x++ {
			if x == 1 {
				fmt.Scanf("\n%1d", &arr[y][x])
				continue
			}
			 fmt.Scanf("%1d", &arr[y][x])
		}
	}

	q := newQueue(1, 1, 1)
	for q.qy.Len() > 0 {
		y, x, c := q.DeQueue()
		if y == N && x == M {
			fmt.Println(c)
			return
		}
		c++

		// up
		if valid(y-1, x) {
			q.Enqueue(y-1, x, c)
		}
		// right
		if valid(y, x+1) {
			q.Enqueue(y, x+1, c)
		}

		// down
		if valid(y+1, x) {
			q.Enqueue(y+1, x, c)
		}

		// left
		if valid(y, x-1) {
			q.Enqueue(y, x-1, c)
		}
	}
}
